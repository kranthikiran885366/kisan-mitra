const mongoose = require("mongoose")

const videoSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },
    description: {
      type: String,
      required: true,
      maxlength: 2000,
    },

    // Video Content
    videoUrl: {
      type: String,
      required: true,
    },
    thumbnailUrl: {
      type: String,
      required: true,
    },
    duration: {
      type: Number, // in seconds
      required: true,
    },
    fileSize: {
      type: Number, // in bytes
    },
    quality: {
      type: String,
      enum: ["360p", "480p", "720p", "1080p"],
      default: "720p",
    },

    // Content Classification
    category: {
      type: String,
      enum: [
        "crop_cultivation",
        "pest_management",
        "disease_control",
        "organic_farming",
        "irrigation_techniques",
        "soil_management",
        "fertilizer_application",
        "harvesting_techniques",
        "post_harvest",
        "farm_equipment",
        "animal_husbandry",
        "government_schemes",
        "market_analysis",
        "weather_management",
        "sustainable_farming",
        "technology_adoption",
      ],
      required: true,
    },
    subcategory: {
      type: String,
      trim: true,
    },

    // Target Audience
    targetAudience: {
      type: String,
      enum: ["beginner", "intermediate", "advanced", "all"],
      default: "all",
    },
    farmingType: [
      {
        type: String,
        enum: ["organic", "conventional", "mixed", "natural", "biodynamic"],
      },
    ],
    applicableRegions: [
      {
        state: String,
        districts: [String],
      },
    ],

    // Seasonal Relevance
    seasons: [
      {
        type: String,
        enum: ["kharif", "rabi", "zaid", "summer", "all_season"],
      },
    ],
    crops: [String], // Applicable crops

    // Creator Information
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    creatorType: {
      type: String,
      enum: ["agriculture_expert", "agri_doctor", "successful_farmer", "government", "ngo"],
      required: true,
    },

    // Language and Accessibility
    language: {
      type: String,
      enum: ["en", "hi", "te", "mixed"],
      required: true,
    },
    subtitles: [
      {
        language: {
          type: String,
          enum: ["en", "hi", "te"],
        },
        url: String,
        isAutoGenerated: { type: Boolean, default: false },
      },
    ],
    transcript: {
      type: String,
      maxlength: 10000,
    },

    // Engagement Metrics
    views: {
      type: Number,
      default: 0,
    },
    likes: [
      {
        user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        likedAt: { type: Date, default: Date.now },
      },
    ],
    dislikes: [
      {
        user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        dislikedAt: { type: Date, default: Date.now },
      },
    ],
    bookmarks: [
      {
        user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        bookmarkedAt: { type: Date, default: Date.now },
      },
    ],
    shares: {
      type: Number,
      default: 0,
    },

    // Comments and Reviews
    comments: [
      {
        user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        content: { type: String, maxlength: 500 },
        rating: { type: Number, min: 1, max: 5 },
        isHelpful: { type: Boolean, default: false },
        replies: [
          {
            user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
            content: { type: String, maxlength: 300 },
            createdAt: { type: Date, default: Date.now },
          },
        ],
        createdAt: { type: Date, default: Date.now },
      },
    ],

    // Content Quality
    rating: {
      average: { type: Number, default: 0, min: 0, max: 5 },
      count: { type: Number, default: 0 },
    },
    isVerified: {
      type: Boolean,
      default: false,
    },
    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },

    // Content Status
    status: {
      type: String,
      enum: ["draft", "pending_review", "published", "archived", "rejected"],
      default: "pending_review",
    },
    publishedAt: Date,

    // SEO and Discovery
    tags: [String],
    keywords: [String],

    // Technical Information
    equipment: [
      {
        name: String,
        brand: String,
        model: String,
        cost: Number,
      },
    ],
    materials: [
      {
        name: String,
        quantity: String,
        cost: Number,
        supplier: String,
      },
    ],

    // Implementation Details
    difficulty: {
      type: String,
      enum: ["easy", "medium", "hard"],
      default: "medium",
    },
    timeRequired: {
      type: String, // e.g., "2 hours", "1 day", "1 week"
    },
    costEstimate: {
      min: Number,
      max: Number,
      currency: { type: String, default: "INR" },
    },

    // Related Content
    relatedVideos: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Video",
      },
    ],
    prerequisites: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Video",
      },
    ],

    // Analytics
    analytics: {
      watchTime: { type: Number, default: 0 }, // total watch time in seconds
      averageWatchTime: { type: Number, default: 0 },
      completionRate: { type: Number, default: 0 }, // percentage
      clickThroughRate: { type: Number, default: 0 },
      deviceStats: {
        mobile: { type: Number, default: 0 },
        desktop: { type: Number, default: 0 },
        tablet: { type: Number, default: 0 },
      },
      locationStats: [
        {
          state: String,
          district: String,
          views: Number,
        },
      ],
    },

    // Moderation
    reportCount: {
      type: Number,
      default: 0,
    },
    reports: [
      {
        user: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        reason: {
          type: String,
          enum: ["inappropriate", "misleading", "spam", "copyright", "other"],
        },
        description: String,
        status: {
          type: String,
          enum: ["pending", "reviewed", "resolved", "dismissed"],
          default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
      },
    ],

    // External Links
    externalLinks: [
      {
        title: String,
        url: String,
        type: {
          type: String,
          enum: ["reference", "product", "research", "government", "other"],
        },
      },
    ],
  },
  {
    timestamps: true,
  },
)

// Indexes for better performance
videoSchema.index({ category: 1, subcategory: 1 })
videoSchema.index({ status: 1, publishedAt: -1 })
videoSchema.index({ createdBy: 1 })
videoSchema.index({ language: 1 })
videoSchema.index({ tags: 1 })
videoSchema.index({ crops: 1 })
videoSchema.index({ "applicableRegions.state": 1 })
videoSchema.index({ "rating.average": -1, views: -1 })
videoSchema.index({ createdAt: -1 })

// Virtual for like count
videoSchema.virtual("likeCount").get(function () {
  return this.likes.length
})

// Virtual for dislike count
videoSchema.virtual("dislikeCount").get(function () {
  return this.dislikes.length
})

// Virtual for bookmark count
videoSchema.virtual("bookmarkCount").get(function () {
  return this.bookmarks.length
})

// Virtual for comment count
videoSchema.virtual("commentCount").get(function () {
  return this.comments.length
})

// Method to add view
videoSchema.methods.addView = function (userId = null, watchTime = 0) {
  this.views += 1
  this.analytics.watchTime += watchTime

  if (this.views > 0) {
    this.analytics.averageWatchTime = this.analytics.watchTime / this.views
    this.analytics.completionRate = (watchTime / this.duration) * 100
  }

  return this.save()
}

// Method to add like
videoSchema.methods.addLike = function (userId) {
  // Remove dislike if exists
  this.dislikes = this.dislikes.filter((dislike) => dislike.user.toString() !== userId.toString())

  // Add like if not already liked
  const existingLike = this.likes.find((like) => like.user.toString() === userId.toString())

  if (!existingLike) {
    this.likes.push({ user: userId })
  }

  return this.save()
}

// Method to add dislike
videoSchema.methods.addDislike = function (userId) {
  // Remove like if exists
  this.likes = this.likes.filter((like) => like.user.toString() !== userId.toString())

  // Add dislike if not already disliked
  const existingDislike = this.dislikes.find((dislike) => dislike.user.toString() === userId.toString())

  if (!existingDislike) {
    this.dislikes.push({ user: userId })
  }

  return this.save()
}

// Method to add bookmark
videoSchema.methods.addBookmark = function (userId) {
  const existingBookmark = this.bookmarks.find((bookmark) => bookmark.user.toString() === userId.toString())

  if (!existingBookmark) {
    this.bookmarks.push({ user: userId })
    return this.save()
  }

  return Promise.resolve(this)
}

// Method to remove bookmark
videoSchema.methods.removeBookmark = function (userId) {
  this.bookmarks = this.bookmarks.filter((bookmark) => bookmark.user.toString() !== userId.toString())

  return this.save()
}

// Method to add comment
videoSchema.methods.addComment = function (userId, content, rating = null) {
  const comment = {
    user: userId,
    content: content,
    rating: rating,
  }

  this.comments.push(comment)

  // Update rating if provided
  if (rating) {
    this.updateRating()
  }

  return this.save()
}

// Method to update rating
videoSchema.methods.updateRating = function () {
  const ratingsWithValues = this.comments.filter((comment) => comment.rating)

  if (ratingsWithValues.length > 0) {
    const totalRating = ratingsWithValues.reduce((sum, comment) => sum + comment.rating, 0)
    this.rating.average = totalRating / ratingsWithValues.length
    this.rating.count = ratingsWithValues.length
  }
}

// Method to check if user has liked
videoSchema.methods.hasUserLiked = function (userId) {
  return this.likes.some((like) => like.user.toString() === userId.toString())
}

// Method to check if user has disliked
videoSchema.methods.hasUserDisliked = function (userId) {
  return this.dislikes.some((dislike) => dislike.user.toString() === userId.toString())
}

// Method to check if user has bookmarked
videoSchema.methods.hasUserBookmarked = function (userId) {
  return this.bookmarks.some((bookmark) => bookmark.user.toString() === userId.toString())
}

// Static method to get trending videos
videoSchema.statics.getTrendingVideos = function (limit = 10, category = null) {
  const query = { status: "published" }
  if (category) query.category = category

  return this.find(query)
    .sort({ views: -1, "rating.average": -1, createdAt: -1 })
    .limit(limit)
    .populate("createdBy", "name role profilePicture")
}

// Static method to get videos by category
videoSchema.statics.getVideosByCategory = function (category, limit = 20) {
  return this.find({
    category: category,
    status: "published",
  })
    .sort({ "rating.average": -1, views: -1 })
    .limit(limit)
    .populate("createdBy", "name role profilePicture")
}

// Static method to search videos
videoSchema.statics.searchVideos = function (searchTerm, filters = {}) {
  const query = {
    status: "published",
    $or: [
      { title: { $regex: searchTerm, $options: "i" } },
      { description: { $regex: searchTerm, $options: "i" } },
      { tags: { $in: [new RegExp(searchTerm, "i")] } },
      { crops: { $in: [new RegExp(searchTerm, "i")] } },
    ],
  }

  // Apply filters
  if (filters.category) query.category = filters.category
  if (filters.language) query.language = filters.language
  if (filters.targetAudience) query.targetAudience = filters.targetAudience
  if (filters.creatorType) query.creatorType = filters.creatorType

  return this.find(query).sort({ "rating.average": -1, views: -1 }).populate("createdBy", "name role profilePicture")
}

module.exports = mongoose.model("Video", videoSchema)
